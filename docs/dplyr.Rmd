---
title: "Data analysis with dplyr"
draft: true
menu: main
weight: 5 
---

{{<admonition title="About the rest of this tutorial" type="note">}}
There are a million different ways to do things in R.
This isn't Python, where solutions on StackOverflow get ranked on how "Pythonic" they are.
If there's something you like about another workflow in R, 
there's nothing stopping you from using it!

In this case, there are three main camps on analyzing dataframes in R:

* **"Base R"** - 
  "Base R" means using only functions and stuff built into your base R installation.
  No external packages or fancy stuff. 
  The focus here is on stability from version to version - 
  your code will never break from an update, 
  but performance and usability aren't always as great.

* **`data.table`** - 
  `data.table` is a dataframe manipulation package known to have very good performance.

* **"The tidyverse"** -
  The "tidyverse" is a collection of packages that 
  overhauls just about everything in R to use a consistent API.
  Has comparable performance with `data.table`.

For much of the rest of this tutorial,
we'll focus on doing things the "tidyverse" way (with a few exceptions).
The biggest reasons is that everything follows a consistent API -
everything in the tidyverse works well together. 
You can often guess how to use a new function because you've used others like it.
It's also got pretty great performance.
When you use stuff from the tidyverse, you can be reasonably confident
that someone has already taken a look at optimizing things to speed things along.
{{</admonition>}}

## Logical indexing

So far, we've covered how to extract certain pieces of data via indexing.
But what we've shown so far only works if we know the exact index
of the data we want (`vector[42]`, for example).
There is a neat trick to extra certain pieces of data in R known as "logical indexing".

Before we start, we need to know a little about comparing things.

`==` is the equality operator in R.

```{r}
1 == 1
```

`!` means "not".
Not `TRUE` is `FALSE`.

```{r}
!TRUE
```

Likewise we can check if something is not equal to something else with `!=`

```{r}
TRUE != TRUE
```

We can also make comparisons with the greater than `>` and less than `<` symbols. 
Pairing these with an equals sign means "greater than or equal to" (`>=`) 
or "less than or equal to" (`<=`).

```{r}
4 < 5
5 <= 5
9 > 999
TRUE >= FALSE
```

The last example worked because `TRUE` and `FALSE` are equal to 1 and 0, respectively.

```{r}
TRUE == 1
FALSE == 1
```

We can even compare strings:

```{r}
"a" == "a"
"a" != "b"
```

This trick also works with vectors, returning `TRUE` or `FALSE` 
for every element in the vector.

```{r}
example <- 1:7
example >= 4
another_example <- c("apple", "banana", "banana")
another_example == "banana"
```

This trick is ***extremely useful*** for getting specific elements.
Watch what happens when we index a vector using a set of boolean values.
Using our example from above:

```{r}
example
greater_than_3 <- example > 3
greater_than_3
example[greater_than_3]
```

This can be turned into a one-liner by putting the boolean expression inside
the square brackets.

```{r}
example[example > 3]
```

We can also get the elements which were not greater than 3 by adding an `!`
in front.

```{r}
example[!example > 3]
```

{{<admonition title="Exercise - Removing NAs from a dataset">}}
Logical indexing is also a pretty neat trick for removing `NA`s from a vector.
Many functions will refuse to work on data with `NA`s present.
The `is.na()` function returns `TRUE` or `FALSE` depending on if a value is `NA`.

Using this info, make the following return a number as a result instead of `NA`.

```{r}
ugly_data <- c(1, NA, 5, 7, NA, NA)
mean(ugly_data)
```
{{</admonition>}}

{{<admonition title="Exercise - The `na.rm` argument">}}
Many functions have an `na.rm` argument used to ignore `NA` values.
Does this work for `mean()` in the previous example?
{{</admonition>}}

## Retrieving rows from dataframes

Let's try this out on a bigger dataset.
`nycflights13` is an example dataset containing 
all outbound flights from NYC in 2013.
You can get this dataset with `install.packages("nycflights13")`.

Let's take a look at the dataset and see what we've got.

```{r}
library(nycflights13)
head(flights)  # shows the top few rows of a dataset
str(flights)
dim(flights)
```



